#!/bin/bash

# This script is meant to be used when the postinst script is called with $1
# set to 'configure' or 'triggered'

set -e
set -u

shopt -s inherit_errexit

DESTDIR="${DESTDIR:-}"

DEFAULT_PROFILE='default'
DISTRO_PROFILES="${DISTRO_PROFILES:-/etc/crypto-config}"
# USER_PROFILES='user/crypto-config'
# ALL_PROFILES="${DISTRO_PROFILES} ${USER_PROFILES}"
ALL_PROFILES="${DISTRO_PROFILES}"
STATE_DIR="${DESTDIR}/var/lib/crypto-config"
STATE_PROFILES_DIR="${STATE_DIR}/profiles"

verbose='false'

log() {
  if "${verbose}"; then
    echo "$@"
  fi
}

dirs_in() {
  # Output the list of directories directly inside a given directory

  local d
  d="${1}"

  find "${d}" -mindepth 1 -maxdepth 1 -type d
}

_list_profiles_and_parent() {
  # Output a list of profiles and their parent in the following format:
  #   profile1 profile1_parent
  #   profile2 profile2_parent

  local profile_dir

  profile_dir="$1"

  for profile in $(dirs_in "${profile_dir}"); do

    profile="$(basename "${profile}")"

    # TODO: switch to the 'metadata.json' file rather than 'parent'
    echo "${profile}" | cat "${profile_dir}/${profile}/parent" -

  done
}

_reach_state() {
  local profile_dir
  local profile
  local apps

  profile_dir="${1}"
  profile="${2}"
  shift 2
  apps=("$@")

  # Skip profiles that don't exist in the current profile directory
  # This is because shell script makes it a fair bit difficult to do the
  # topological sort on profile names and keep track of which directory
  # they come from.
  if ! [ -e "${profile_dir}/${profile}" ]; then
    return
  fi

  log "  - Profile: ${profile}"

  # The default profile has no parent by definition and does not need to be
  # modified since it is the single source of truth
  case "${profile}" in
    "${DEFAULT_PROFILE}")
      log "    - source of truth"
      # Symlink to the directory where the profile lives: it is required to be
      # complete already, therefore we can use it directly
      ln -sfn "${profile_dir}/${profile}" "${STATE_PROFILES_DIR}/${profile}"
      return;;
  esac

  # Ensure the profile directory exists in the state directory
  mkdir -p "${STATE_PROFILES_DIR}/${profile}"

  # Due to the call to tsort we couldn't easily keep the information on
  # where the profiles reside. Recover that.
  parent_profile="$(cat "${profile_dir}/${profile}/parent")"

  for app in "${apps[@]}"; do

    if [[ -z "${app}" ]]; then
      continue
    fi

    src="${STATE_PROFILES_DIR}/${profile}/${app}"
    target="${STATE_PROFILES_DIR}/${parent_profile}/${app}"

    # If app profile exists in the parent profile, we create a symlink to there.
    # If it doesn't, it means the symlink must not exist and must be removed if
    # it does.
    if [[ -e "$(realpath -m "${target}")" ]]; then
      log "    - ${app}: link to ${target}"
      ln -sfn "${target}" "${src}"
    else
      if [[ -e "${src}" ]] || [[ -L "${src}" ]]; then
        log "    - ${app}: remove"
      else
        log "    - ${app}: absent"
      fi
      rm -f "${src}"
    fi

  done

  # TODO: remove profiles that have been removed
}

_update_profile() {
  local profile_dir
  local apps

  profile_dir="${1}"
  shift
  apps=("$@")

  if ! [ -d "${profile_dir}" ]; then
    return
  fi

  log "- Profile dir: ${profile_dir}"

  # TODO: profile names must be unique across profile directories

  _list_profiles_and_parent "${profile_dir}" \
  | tsort \
  | while read -r profile; do
      _reach_state "${profile_dir}" "${profile}" "${apps[@]}"
  done
}

triggered() {
  local apps

  apps=("$@")

  for profile_dir in ${ALL_PROFILES}; do
    _update_profile "${DESTDIR}${profile_dir}" "${apps[@]}"
  done
}

case "$1" in
  triggered|configure)
    shift
    triggered "$@"
    ;;
esac

#DEBHELPER#

exit 0
